package id.ac.ui.cs.advprog.productservice.repository;

import id.ac.ui.cs.advprog.productservice.model.Payment;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;

import java.util.Date;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;

@DataJpaTest
public class PaymentRepositoryTest {

    @Autowired
    private PaymentRepository repository;

    @BeforeEach
    void setUp() {
        repository.deleteAll();
    }

    @Test
    void testSavePaymentSuccessfully() {
        Payment newPayment = new Payment();
        newPayment.setCustomerId("c2");
        newPayment.setAmount(150.0);
        newPayment.setMethod("DANA");
        newPayment.setStatus("LUNAS");

        Payment saved = repository.save(newPayment);

        assertNotNull(saved.getId(), "ID should be generated by Hibernate and not null");
        assertTrue(saved.getId().matches("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$"), "ID should be a valid UUID");
        assertEquals("c2", saved.getCustomerId());
        assertEquals(150.0, saved.getAmount());
        assertEquals("DANA", saved.getMethod());
        assertEquals("LUNAS", saved.getStatus());
    }

    @Test
    void testFindByIdSuccessfully() {
        Payment paymentToSave = new Payment(null, "c1-find", 100.0, "OVO", "PENDING", new Date());
        Payment savedPayment = repository.save(paymentToSave);
        String generatedId = savedPayment.getId();

        Optional<Payment> foundPayment = repository.findById(generatedId);

        assertTrue(foundPayment.isPresent(), "Payment should be found with generated ID");
        assertEquals(generatedId, foundPayment.get().getId());
        assertEquals("c1-find", foundPayment.get().getCustomerId());
    }

    @Test
    void testFindByCustomerIdSuccessfully() {
        Payment payment1 = new Payment(null, "c1-cust", 100.0, "OVO", "PENDING", new Date());
        repository.save(payment1);
        Payment payment2 = new Payment(null, "c1-cust", 200.0, "GOPAY", "LUNAS", new Date());
        Payment savedPayment2 = repository.save(payment2);

        List<Payment> foundPayments = repository.findByCustomerId("c1-cust");

        assertNotNull(foundPayments);
        assertEquals(2, foundPayments.size(), "Should find 2 payments for customer c1-cust");
        assertTrue(foundPayments.stream().anyMatch(p -> p.getId().equals(payment1.getId())));
        assertTrue(foundPayments.stream().anyMatch(p -> p.getId().equals(savedPayment2.getId())));
    }

    @Test
    void testUpdateSuccessfully() {
        Payment paymentToSave = new Payment(null, "c1-update", 100.0, "OVO", "PENDING", new Date());
        Payment savedPayment = repository.save(paymentToSave);
        String generatedId = savedPayment.getId();

        Payment paymentToUpdate = repository.findById(generatedId).orElseThrow(() -> new AssertionError("Payment not found for update"));

        paymentToUpdate.setStatus("COMPLETED");
        paymentToUpdate.setAmount(120.0);
        Payment updatedPayment = repository.save(paymentToUpdate);

        assertNotNull(updatedPayment);
        assertEquals(generatedId, updatedPayment.getId(), "ID should remain the same after update");
        assertEquals("COMPLETED", updatedPayment.getStatus());
        assertEquals(120.0, updatedPayment.getAmount());

        Optional<Payment> verifiedPayment = repository.findById(generatedId);
        assertTrue(verifiedPayment.isPresent());
        assertEquals("COMPLETED", verifiedPayment.get().getStatus());
        assertEquals(120.0, verifiedPayment.get().getAmount());
    }

    @Test
    void testDeleteSuccessfully() {
        Payment paymentToSave = new Payment(null, "c1-delete", 100.0, "OVO", "PENDING", new Date());
        Payment savedPayment = repository.save(paymentToSave);
        String generatedId = savedPayment.getId();

        assertTrue(repository.existsById(generatedId), "Payment should exist before delete");

        repository.deleteById(generatedId);

        Optional<Payment> deletedPayment = repository.findById(generatedId);
        assertFalse(deletedPayment.isPresent(), "Payment should not be found after deletion");
    }

    @Test
    void testFindByIdNotFound() {
        Optional<Payment> notFound = repository.findById("nonexistent-uuid-format-if-you-want");
        assertFalse(notFound.isPresent());
    }

    @Test
    void testFindByCustomerIdNotFound() {
        List<Payment> notFound = repository.findByCustomerId("unknown-customer-id");
        assertNotNull(notFound);
        assertTrue(notFound.isEmpty());
    }

    @Test
    void testUpdateNonExistentPayment() {
        Payment newPaymentWithFakeId = new Payment(null, "cx-nonexistent", 0.0, "GOPAY", "PENDING", new Date());

        Payment result = repository.save(newPaymentWithFakeId);
        assertNotNull(result.getId(), "ID should be generated even if we intended to simulate update on non-existent");
        assertEquals("cx-nonexistent", result.getCustomerId());
    }

    @Test
    void testDeleteNonExistentPayment() {
        String nonExistentId = "nonexistent-id-for-delete";
        assertDoesNotThrow(() -> {
            repository.deleteById(nonExistentId);
        });
        assertFalse(repository.existsById(nonExistentId));
        Payment nonExistentEntity = new Payment(null, "c99", 50.0, "OVO", "PENDING", new Date());

        assertDoesNotThrow(() -> {
            repository.delete(nonExistentEntity);
        });
    }
}